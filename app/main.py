import os
import re
import sys
import asyncio
import time
from urllib.parse import urlparse

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse, FileResponse

from app.core.config import settings
from app.models.schemas import DocProcessRequest, DocProcessResponse
from app.services.graph import run_workflow
from app.core.logger import get_logger

# =================================================================
# 核心修复：Windows下强制使用 ProactorEventLoop
# 必须在所有 import 之前 (甚至在导入 Uvicorn 之前) 执行
# =================================================================
if sys.platform == 'win32':
    asyncio.set_event_loop_policy(asyncio.WindowsProactorEventLoopPolicy())

logger = get_logger("MainAPI")

app = FastAPI(
    title=settings.PROJECT_NAME,
    openapi_url=f"{settings.API_V1_STR}/openapi.json"
)

# 允许跨域
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# 定义临时文件存储目录
TEMP_DIR = os.path.join(os.getcwd(), "temp_downloads")
if not os.path.exists(TEMP_DIR):
    os.makedirs(TEMP_DIR)


# -----------------------------------------------------------------
# 辅助函数：文件清理与文件名生成
# -----------------------------------------------------------------
def cleanup_file(path: str):
    """后台任务：下载完成后删除临时文件"""
    try:
        if os.path.exists(path):
            os.remove(path)
            logger.info(f"Deleted temp file: {path}")
    except Exception as e:
        logger.error(f"Error deleting temp file {path}: {e}")


def get_filename_from_url(url: str) -> str:
    """根据URL生成合法的文件名"""
    parsed = urlparse(url)
    # 取路径部分的最后一段，如果是空则用域名
    name = parsed.path.strip("/").replace("/", "-")
    if not name:
        name = parsed.netloc.replace(".", "-")

    # 移除非法字符
    name = re.sub(r'[\\/*?:"<>|]', "", name)
    # 添加时间戳防止重名
    timestamp = int(time.time())
    return f"{name}-{timestamp}.md"


@app.post(
    f"{settings.API_V1_STR}/process",
    response_model=DocProcessResponse,
    summary="智能处理文档（支持下载）"
)
async def process_document(request: DocProcessRequest):
    """
    接收 URL，启动 Crawl4AI -> LangGraph -> LLM 流程。

    参数:
    - **url**: 目标网页 URL
    - **download**: 如果为 True，将直接返回 .md 文件下载流；否则返回 JSON 数据。
    """

    logger.info(f"Received request for: {request.url}, download={request.download}")

    # 执行工作量
    result = await run_workflow(str(request.url))

    if result.get("error"):
        logger.error(f"Workflow failed: {result['error']}")
        return JSONResponse(
            status_code=200,  # 或者是 400/500，视业务需求而定
            content={
                "url": str(request.url),
                "processed_markdown": "",
                "status": "error",
                "error": result["error"]
            }
        )
    if request.download:
        filename = get_filename_from_url(str(request.url))
        file_path = os.path.join(TEMP_DIR, filename)

        content = result.get("final_output")
        header = f"> Source: {request.url}\n> Generated by SmartDoc Assistant\n\n"
        with open(file_path, "w", encoding="utf-8") as f:
            f.write(header + content)

        logger.info(f"File generated at: {file_path}")

        return FileResponse(
            path=file_path,
            filename=filename,
            media_type="text/markdown",
            # background=background_tasks.add_task(cleanup_file, file_path)
        )

    return DocProcessResponse(
        url=str(request.url),
        processed_markdown=result["final_output"],
        discovered_links=result["links"]
    )


if __name__ == "__main__":
    import uvicorn

    # =================================================================
    # 核心修复：PyCharm 直接启动配置
    # 1. loop="asyncio" -> 强制 Uvicorn 使用标准 asyncio，从而应用我们在上面设置的 Proactor 策略
    # 2. reload=False -> 在 Windows PyCharm 调试模式下，建议关闭 reload，避免子进程锁问题
    # =================================================================
    uvicorn.run(
        "app.main:app",
        host="0.0.0.0",
        port=8000,
        loop="asyncio"  # <--- 关键！不要用默认的 auto
    )
